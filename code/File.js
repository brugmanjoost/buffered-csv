const EventEmitter	= require('events');
const util			= require('util');
const fs			= require('fs');
const _				= require('private-parts').createKey();

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Enums
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var STATE_OPEN		= true;
var STATE_CLOSED	= false;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Field type convertors
//
// These are used to convert individual values in a data object to a CSV representation. options.fields[name].type references the name of the
// handlers here.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var convertors = {
	'string': function(value) {
		if(value.toString === undefined)
			throw 'not_a_string';
		return this.quote + value.toString().replace(this.quote, this.escape + this.quote) + this.quote;
	},

	'number': function(value) {
		var value = (new Number(value)).valueOf();
		if(Number.isNaN(value))
			throw 'not_a_number';
		return value;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var File = module.exports = function(options) {
	EventEmitter.call(this);
	_getOptions.call(this, options);
	_(this).open = false;
}
util.inherits(File, EventEmitter);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:
//
// Description:
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var _requireState = function(requiredState) {
	if(requiredState !== _(this).open)
		throw requiredState == STATE_OPEN ? 'not_open' : 'open';
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:
//
// Description:
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var _getOptions = function(options) {

	var _getOne = function(name, defaultValue) {
		return (options === undefined || options[name] === undefined ) ? defaultValue : options[name];
	}

	this.encoding		= _getOne('encoding',		'utf8');
	this.delimeter		= _getOne('delimeter',		',');
	this.quote			= _getOne('quote',			'"');
	this.escape			= _getOne('escape',			'\\');
	this.nullValue		= _getOne('nullValue',		'NULL');
	this.eol			= _getOne('eol',			require('os').EOL);
	this.headers		= _getOne('headers',		true);
	this.overwrite		= _getOne('overwrite', 		true);
	this.fields			= _getOne('fields',			{});
	this.flushInterval	= _getOne('flushInterval',	0);
	this.flushLines		= _getOne('flushLines',		0);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:
//
// Description:
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var _getPath = function() {
	return (typeof this.path !== 'function') ? this.path : this.path();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:	_updateCurrentFields
//
// Description:	Under the condition that an object is passed as a parameter to add() then the object holds field names and values. Possibly there are
//				some field names that were not previously passed, in which case we'll add them to the end of the fieldlist. The result is that the
//				associated value get's added to the end of the line and future references to this field will have their values placed at the same
//				position in the csv line.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var _updateCurrentFields = function(data) {
	var _that = this;

	var names = Object.keys(data);
	names.forEach(function(name) {
		if(_(_that).currentFields[name] !== undefined)
			return;
		_(_that).currentFields[name] = {
			type: 'string'
		}
	});
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:	_buildDataset
//
// Description:
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var _buildDataset = function(data) {
	var _that = this;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(Array.isArray(data))
		return data;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_updateCurrentFields.call(this, data);
	var dataset = [];
	Object.keys(_(this).currentFields).forEach(function(name) {
		dataset.push(data[name]);
	});
	return dataset;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:
//
// Description:
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var _generateCsvHeaders = function() {
	return Object.keys(_(this).currentFields).map(function(value) {
		return convertors.string.call(this, value);
	}, this).join(this.delimeter) + this.eol
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:
//
// Description:
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
var _generateCsvData = function() {
	var headerIndices = Object.keys(_(this).currentFields);
	return _(this).buffer.map(function(lineData) {
		return lineData.map(function(value, index) {
			return value === undefined
				? this.nullValue
				: convertors[headerIndices[index] === undefined
								? 'string'
								: _(this).currentFields[headerIndices[index]].type
							].call(this, value);
		}, this).join(this.delimeter) + this.eol;
	}, this).join('');
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:	open
//
// Description:
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
File.prototype.open = function(path) {
	_requireState.call(this, STATE_CLOSED);

	var _that = this;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Setup internal data structures
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	this.path				= path;
	_(this).lastPath		= null;
	_(this).buffer			= [];
	_(this).currentFields	= JSON.parse(JSON.stringify(this.fields));	// We create a copy to work with for this file.

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Start timer for interval based flushing
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(this.flushInterval > 0)
		_(this).timerFlushInterval = setInterval(function() {
			_that.flush();
		}, this.flushInterval);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_(this).open = true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:	close
//
// Description:
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
File.prototype.close = function() {
	_requireState.call(this, STATE_OPEN);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Stop flush interval
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(_(this).timerFlushInterval !== null) {
		clearInterval(_(this).timerFlushInterval);
		_(this).timerFlushInterval = null;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Perform final flush
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	this.flush();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:	add
//
// Description:	Adds a line to the csv file
//
// Parameters:	data can be an array or an object.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
File.prototype.add = function(data) {
	_requireState.call(this, STATE_OPEN);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Only accept arrays or key/value maps
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(typeof data !== 'object')
		throw 'invalid_data';

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Add the new data to our buffer
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_(this).buffer.push(_buildDataset.call(this, data));

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Decide wether to flush for flushLines
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if((this.flushLines > 0) && (_(this).buffer.length > this.flushLines))
		this.flush();

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Decide wether to flush for all else
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	else if((this.flushLines == 0) && (this.flushInterval == 0))
		this.flush();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Function:	flush
//
// Description:
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
File.prototype.flush = function() {
	_requireState.call(this, STATE_OPEN);
	var _that = this;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Nothing to flush
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if(_(this).buffer.length == 0)
		return;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Determine output file
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	var path = _getPath.call(this);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Generate data output
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	var csv = ((this.headers && (_(this).lastPath != path)) ? _generateCsvHeaders.call(this) : '') + _generateCsvData.call(this);
	_(this).buffer = [];

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Actually save output
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	this.emit('data', path, csv);

	var saveFunction = fs[(this.overwrite && (_(this).lastPath != path)) ? 'writeFile' : 'appendFile'];
	saveFunction(path, csv, {
		encoding: this.encoding
	}, function(err) {
		if(err)
			_that.emit('error', err, path, csv);
	});

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Track last used path so we know if we:
	// a) need to write headers
	// b) need to append or overwrite
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	_(this).lastPath = path;
}


